/*
 * MIT License
 *
 * Copyright (c) 2018 Charalampos Savvidis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.lowbudget.chess.model.uci.protocol.message;

import com.lowbudget.chess.model.Move;
import com.lowbudget.chess.model.uci.protocol.message.SimpleMessage.UnknownMessage;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toMap;

/**
 * <p>Encapsulates a message received or sent during the communication between the GUI and the engine.</p>
 * <p>This class controls the creation of its instances using static factory methods (for some types that
 * don't have additional parameters other than their command i.e. like {@link SimpleMessage#UCI} a single instance is sufficient).</p>
 * <p>This class and and all of its descendants are immutable.</p>
 */
public abstract class UCIMessage {

	/**
	 * <p>The type of a UCI message.</p>
	 */
	@SuppressWarnings("SpellCheckingInspection")
	public enum Type {
		// GUI to engine
		UCI("uci", true),
		DEBUG("debug", true),
		IS_READY("isready", true),
		SET_OPTION("setoption", true),
		REGISTER("register", true),
		UCI_NEW_GAME("ucinewgame", true),
		POSITION("position", true),
		GO("go", true),
		STOP("stop", true),
		PONDER_HIT("ponderhit", true),
		QUIT("quit", true),

		// engine to GUI
		ID("id"),
		UCI_OK("uciok"),
		READY_OK("readyok"),
		BEST_MOVE("bestmove"),
		COPY_PROTECTION("copyprotection"),
		REGISTRATION("registration"),
		INFO("info"),
		OPTION("option"),

		// pseudo type for messages that are not actual commands (i.e. most engines send an infromative header when they start)
		UNKNOWN("unknown");

		/**
		 * The basic command that this type represents as defined by the UCI protocol. Note that each command can have
		 * additional parameters.
		 */
		private final String command;

		/**
		 * Denotes if this message is initiated by the GUI (otherwise it is initiated by the engine).
		 */
		private final boolean fromGUI;

		Type(String command) {
			this(command, false);
		}
		Type(String command, boolean isFromGUI) {
			this.command = command;
			this.fromGUI = isFromGUI;
		}

		public String command() {
			return command;
		}

		public boolean isFromEngine() {
			return !fromGUI;
		}
		public boolean isFromGUI() {
			return fromGUI;
		}

		public boolean isKnown() {
			return this != Type.UNKNOWN;
		}

		/**
		 * A mapping from the string command to the Type enum only for the messages generated by the engine
		 */
		private static final Map<String, Type> ENGINE_TYPES = Stream.of(values())
				.filter(Type::isFromEngine)
				.collect( toMap(Type::command, Function.identity()) );

		/**
		 * A mapping from the string command to the Type enum only for the messages generated by the client
		 */
		private static final Map<String, Type> CLIENT_TYPES = Stream.of(values())
				.filter(Type::isFromGUI)
				.collect( toMap(Type::command, Function.identity()) );

		public static final String[] ENGINE_COMMAND_TOKENS = new ArrayList<>(ENGINE_TYPES.keySet()).toArray(new String[0]);

		public static final String[] CLIENT_COMMAND_TOKENS = new ArrayList<>(CLIENT_TYPES.keySet()).toArray(new String[0]);
	}

	/**
	 * Tokens used as keywords by the UCI protocol
	 */
	@SuppressWarnings("SpellCheckingInspection")
	public static final class Token {
		private Token() {}

		public static final String NAME = "name";
		public static final String AUTHOR = "author";
		public static final String TYPE = "type";
		public static final String DEFAULT = "default";
		public static final String MIN = "min";
		public static final String MAX = "max";
		public static final String VAR = "var";
		public static final String CHECK = "check";
		public static final String SPIN = "spin";
		public static final String COMBO = "combo";
		public static final String STRING = "string";
		public static final String BUTTON = "button";
		public static final String OK = "ok";
		public static final String CHECKING = "checking";
		public static final String ERROR = "error";
		public static final String PONDER = "ponder";
		public static final String LATER = "later";

		public static final String DEPTH = "depth";
		public static final String SEL_DEPTH = "seldepth";
		public static final String TIME = "time";
		public static final String NODES = "nodes";
		public static final String PV = "pv";
		public static final String MULTI_PV = "multipv";

		public static final String SCORE = "score";
		public static final String CP = "cp";
		public static final String MATE = "mate";
		public static final String LOWER_BOUND = "lowerbound";
		public static final String UPPER_BOUND = "upperbound";

		public static final String CURR_MOVE = "currmove";
		public static final String CURR_MOVE_NUMBER = "currmovenumber";
		public static final String HASH_FULL = "hashfull";
		public static final String NPS = "nps";
		public static final String TB_HITS = "tbhits";
		public static final String SB_HITS = "sbhits";
		public static final String CPU_LOAD = "cpuload";
		public static final String REFUTATION = "refutation";
		public static final String CURR_LINE = "currline";

		public static final String VALUE = "value";
		public static final String CODE = "code";
		public static final String ON = "on";
		public static final String OFF = "off";
		public static final String FEN = "fen";
		public static final String MOVES = "moves";
		public static final String START_POS = "startpos";
		public static final String WHITE_TIME = "wtime";
		public static final String BLACK_TIME = "btime";
		public static final String WHITE_INC = "winc";
		public static final String BLACK_INC = "binc";
		public static final String MOVES_TO_GO = "movestogo";
		public static final String MOVE_TIME = "movetime";
		public static final String INFINITE = "infinite";
		public static final String SEARCH_MOVES = "searchmoves";

		// standard option names
		public static final String OPTION_UCI_OPPONENT = "UCI_Opponent";
		public static final String NONE = "none";
		public static final String COMPUTER = "computer";
		public static final String HUMAN = "human";

		public enum OpponentTitle {
			GM, IM, FM, WGM, WIM, NONE;

			public static String[] toTokens() {
				return Arrays.stream(OpponentTitle.values()).map(title -> title == NONE ? Token.NONE : title.toString()).toArray(String[]::new);
			}

			public static OpponentTitle fromString(String title) {
				return Token.NONE.equals(title) ? NONE : valueOf(title);
			}

			@Override
			public String toString() {
				return this == NONE ? Token.NONE : super.toString();
			}
		}

		public static final Set<String> INFO_TOKENS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
				DEPTH, SEL_DEPTH, TIME, NODES, PV, MULTI_PV, SCORE, CP, MATE, LOWER_BOUND, UPPER_BOUND, STRING,
				CURR_MOVE, CURR_MOVE_NUMBER, HASH_FULL, NPS, TB_HITS, SB_HITS, CPU_LOAD, REFUTATION, CURR_LINE
		)));
		public static final Set<String> GO_TOKENS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
				SEARCH_MOVES, PONDER, WHITE_TIME, BLACK_TIME, WHITE_INC, BLACK_INC, MOVES_TO_GO,
				DEPTH, NODES, MATE, MOVE_TIME, INFINITE
		)));

	}

	/**
	 * <p>Identifies the Type from its string representation for engine message types.</p>
	 * @param command the string representation that we want to map to an enum value
	 * @return The {@link Type} that is represented by the specified string if it represents a valid engine command or
	 * {@link Type#UNKNOWN} otherwise.
	 */
	public static Type getEngineMessageType(String command) {
		Type result = Type.ENGINE_TYPES.get(command);
		if (result == null) {
			result = Type.UNKNOWN;
		}
		return result;
	}

	/**
	 * <p>Identifies the Type from its string representation for gui message types.</p>
	 * @param command the string representation that we want to map to an enum value
	 * @return The {@link Type} that is represented by the specified string if it represents a valid client command or
	 * {@link Type#UNKNOWN} otherwise.
	 */
	public static Type getClientMessageType(String command) {
		Type result = Type.CLIENT_TYPES.get(command);
		if (result == null) {
			result = Type.UNKNOWN;
		}
		return result;
	}

	/**
	 * The type of this message
	 */
	private final Type type;

	UCIMessage(Type type) {
		this.type = Objects.requireNonNull(type, "Type cannot be null");
	}

	public Type getType() {
		return type;
	}

	/**
	 * Converts this message to the string representation that should be used according to UCI protocol, when
	 * sending the message to the engine
	 * @return the UCI command for this message
	 */
	public abstract String toCommand();

	@Override
	public String toString() {
		return getClass().getSimpleName() + " [" + getType() + "]: " + toCommand();
	}


	/*
	 * Static factories for various message types.
	 */

	public static SimpleMessage newUnknownMessage(String command) {
		return new UnknownMessage(command);
	}
	public static IdNameMessage newIdNameMessage(String value) {
		return new IdNameMessage(value);
	}
	public static IdAuthorMessage newIdAuthorMessage(String value) {
		return new IdAuthorMessage(value);
	}
	public static OptionMessage.ButtonOptionMessage newButtonOption(String name) {
		return new OptionMessage.ButtonOptionMessage(name);
	}
	public static OptionMessage.CheckOptionMessage newCheckOption(String name, boolean defaultValue) {
		return new OptionMessage.CheckOptionMessage(name, defaultValue);
	}
	public static OptionMessage.StringOptionMessage newStringOption(String name, String defaultValue) {
		return new OptionMessage.StringOptionMessage(name, defaultValue);
	}
	public static OptionMessage.ComboOptionMessage newComboOption(String name, String defaultValue, List<String> comboOptions) {
		return new OptionMessage.ComboOptionMessage(name, defaultValue, comboOptions);
	}
	public static OptionMessage.SpinOptionMessage newSpinOption(String name, int defaultValue, int min, int max) {
		return new OptionMessage.SpinOptionMessage(name, defaultValue, min, max);
	}
	public static BestMoveMessage newBestMoveMessage(Move move, Move ponderMove) {
		return new BestMoveMessage(move, ponderMove);
	}
	public static SetOptionMessage newSetOptionMessage(String name, String value) {
		return new SetOptionMessage(name, value);
	}
	public static SetOptionMessage newSetOptionUCIOpponentMessage(Token.OpponentTitle title, int elo, boolean isComputer, String name) {
		return new SetOptionMessage.OpponentMessage(title, elo, isComputer, name);
	}
	public static RegisterMessage newRegisterMessage(String name, String code) {
		return new RegisterMessage(Objects.requireNonNull(name), Objects.requireNonNull(code));
	}
	public static PositionMessage newFenPositionMessage(String fen, List<Move> moves) {
		return new PositionMessage(fen, moves);
	}
	public static PositionMessage newStartPositionMessage() {
		return newStartPositionMessage(new ArrayList<>());
	}
	public static PositionMessage newStartPositionMessage(List<Move> moves) {
		return new PositionMessage(moves);
	}

}
