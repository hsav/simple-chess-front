/*
 * MIT License
 *
 * Copyright (c) 2018 Charalampos Savvidis
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.lowbudget.chess.front.swing.common;

import com.lowbudget.common.RecentHistory.RecentHistoryListener;
import com.lowbudget.common.ReadOnlyRecentHistory;

import javax.swing.*;
import java.awt.event.ActionEvent;

/**
 * <p>A {@link JMenu} descendant that can display the recent items managed by a {@link ReadOnlyRecentHistory} object.</p>
 * <p>The menu listens for changes in the history and automatically adjusts its children to contain as many items as
 * necessary to display the items of that history.</p>
 * <p>The only external information that needs to be provided, is a {@link RecentMenuActionFactory} that creates new
 * {@link RecentMenuAction}s to be assigned to each {@link JMenuItem} that is dynamically created.</p>
 * <p>Such actions can retrieve the history item they correspond to, by examining their action property named {@link #RECENT_ITEM_PROPERTY_NAME}.</p>
 * <p>Example: </p>
 * <pre>
 *     // action that will be assigned to menu items that display the history items
 *     // in this example it is assumed that the history stores strings but it can store any type of items
 *     class MenuItemAction extends AbstractAction implements RecentMenuAction {
 *
 *         public void actionPerformed(ActionEvent event) {
 *             // this will have been set by the menu before this method is invoked
 *             String item = (String) getValue(RecentHistoryMenu.RECENT_ITEM_PROPERTY_NAME);
 *
 *             // do something with the item here
 *         }
 *
 *         public void onActionAddedToMenu() {
 *             // do here any initialization required when this action is assigned to a menu item
 *             // this is a default method so you don't need to override it if you don't need to
 *         }
 *         public void onActionRemovedFromMenu() {
 *             // do here any clean-up required when this action is removed from the menu and it will not be used anymore
 *             // this is a default method so you don't need to override it if you don't need to
 *         }
 *     }
 *
 *     // a history that remembers strings
 *     ReadOnlyRecentHistory&lt;String&gt; history = new RecentHistory&lt;&gt;();
 *
 *     // you can add this menu to a menu toolbar like any other menu
 *     // note that since the factory is a functional interface it can be provided by a simple lambda
 *     RecentHistoryMenu&lt;String&gt; recentMenu = new RecentHistoryMenu&lt;&gt;("Recent", history, MenuItemAction::new);
 *
 * </pre>
 * @param <T> the type of the items of the {@link ReadOnlyRecentHistory} the menu displays
 */
public class RecentHistoryMenu<T> extends JMenu {

	/**
	 * <p>Action property name under which the item that is assigned to a menu item is stored.</p>
	 * <p>In your {@link Action#actionPerformed(ActionEvent)} method you can retrieve the history item by invoking
	 * {@code getValue(RECENT_ITEM_PROPERTY_NAME)}.</p>
	 */
	public static final String RECENT_ITEM_PROPERTY_NAME = RecentHistoryMenu.class.getName() + "_RECENT_ITEM";

	/**
	 * <p>Factory that creates instances of new {@link RecentMenuAction}s that are appropriate to be assigned to each
	 * menu item that is dynamically generated as the corresponding {@link ReadOnlyRecentHistory} changes.</p>
	 */
	@FunctionalInterface
	public interface RecentMenuActionFactory {
		RecentMenuAction createAction();
	}

	/**
	 * <p>Interface that an action needs to conform to, so it can be assignable to the menu items generated by this menu.</p>
	 * <p>Note that the new methods defined are {@code default} so we can practically accept any {@link Action}.</p>
	 * <p>The action needs to be able to handle items stored in the {@link ReadOnlyRecentHistory}. If for example the history
	 * stores the most recent files opened, this action needs to be able to do open a file.</p>
	 */
	public interface RecentMenuAction extends Action {
		/**
		 * Notifies the action that it has been assigned to a menu item and will now be in use
		 */
		default void onActionAddedToMenu() {}

		/**
		 * Notifies the action that its corresponding menu item has been removed from the menu, so will no longer be used
		 */
		default void onActionRemovedFromMenu() {}

		/**
		 * Converts the item that corresponds to this action to a friendly string appropriate to be displayed in the
		 * menu.
		 * By default the item is converted to string using {@link String#valueOf(Object)}
		 * @param item the recent item this menu item represents
		 * @return a {@link String} description of the menu item
		 */
		default String getMenuItemDescription(Object item) { return String.valueOf(item); }
	}

	/**
	 * The factory that provides us with new {@link RecentMenuAction}s to be assigned to menu items of this menu
	 */
	private final RecentMenuActionFactory recentMenuActionFactory;

	/**
	 * Create a new menu for a {@link ReadOnlyRecentHistory}
	 * @param title the title of the menu
	 * @param history the history object this menu shows
	 * @param recentMenuActionFactory a factory that creates new instances of {@link RecentMenuAction}s that can be
	 * assigned to new menu items
	 */
	public RecentHistoryMenu(String title, ReadOnlyRecentHistory<T> history, RecentMenuActionFactory recentMenuActionFactory) {
		super(title);
		this.recentMenuActionFactory = recentMenuActionFactory;
		// add this menu as a listener to the history object so it can respond to history changes
		history.addRecentHistoryListener(new DefaultRecentHistoryListener());
		// synchronize the menu with the items in the history
		synchronizeMenuItems(history);
	}

	/**
	 * <p>Synchronizes this menu with the current items in the history specified.</p>
	 * <p>New menu items will be added or existing menu items will be removed so the menu displays all the history's
	 * items</p>
	 * @param history the {@link ReadOnlyRecentHistory} object to synchronize this menu with
	 */
	private void synchronizeMenuItems(ReadOnlyRecentHistory<T> history) {
		// get the counts to decide if we need to modify the menu
		int menuItems = getItemCount();
		int totalRecentItems = history.getItemCount();

		//log.debug("Menu items: " + menuItems + ", total recent files: " + configurationItems);

		// we will update as many items as the smallest of the menu items number and the history item number
		int itemsToUpdate = menuItems <= totalRecentItems ? menuItems : totalRecentItems;

		updateItems(itemsToUpdate, history);

		// if the history contains more items than this menu new items will be added
		addItems(menuItems, totalRecentItems, history);

		// if this menu has more menu items than the history then the extra menu items will be removed
		removeItems(menuItems - totalRecentItems);

		// the menu is enabled if it contains at least one menu item
		setEnabled( getItemCount() > 0 );
	}

	private void updateItems(int menuItems, ReadOnlyRecentHistory<T> history) {
		for (int i = 0; i < menuItems; i++) {
			JMenuItem menuItem = this.getItem(i);
			RecentMenuAction action = (RecentMenuAction) menuItem.getAction();
			setItem(action, history.getRecentItem(i));
		}
	}

	private void addItems(int startIndex, int total, ReadOnlyRecentHistory<T> history) {
		for (int i = startIndex; i < total; i++) {
			RecentMenuAction action = this.recentMenuActionFactory.createAction();
			setItem(action, history.getRecentItem(i));
			this.add(action);
			action.onActionAddedToMenu();
		}
	}

	private void removeItems(int removeCount) {
		// remove the number of menu items specified from the end of the menu
		for (int i = 0; i < removeCount; i++) {
			int lastIndex = this.getItemCount() - 1;
			JMenuItem menuItem = this.getItem(lastIndex);
			RecentMenuAction action = (RecentMenuAction) menuItem.getAction();
			setItem(action, null);
			this.remove(lastIndex);
			action.onActionRemovedFromMenu();
		}
	}

	private void setItem(RecentMenuAction action, T item) {
		// "<null>" should never be displayed since the menu item is being removed
		String itemAsString = item != null ? action.getMenuItemDescription(item) : "<null>";
		action.putValue(Action.NAME, itemAsString);
		action.putValue(Action.SHORT_DESCRIPTION, itemAsString);
		action.putValue(RECENT_ITEM_PROPERTY_NAME, item);
	}

	/**
	 * Listens for changes in the history that was used to create this menu
	 */
	private class DefaultRecentHistoryListener implements RecentHistoryListener<T> {

		@Override
		public void onItemAdded(ReadOnlyRecentHistory<T> history, T item) {
			synchronizeMenuItems(history);
		}

		@Override
		public void onItemRemoved(ReadOnlyRecentHistory<T> history, T item) {
			synchronizeMenuItems(history);
		}
	}
}
